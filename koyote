vector<int> kmp(const string &s) {
    int _n = (int)s.size();
    vector<int> ret = vector<int>(_n);
    for (int i = 1, j = 0; i < _n; i++) {
        while (j && s[i] != s[j]) j = ret[j - 1];
        if (s[i] == s[j]) j++;
        ret[i] = j;
    }
    return ret;
}

vector<int> Z(const string &s) {
    int _n = (int)s.size();
    vector<int> ret = vector<int>(_n);
    for (int i = 1, l = 0, r = 0; i < _n; i++) {
        if (i <= r) ret[i] = min(ret[i - l], r - i + 1);
        while (i + ret[i] < _n && s[ret[i]] == s[i + ret[i]]) ret[i]++;
        if (i + ret[i] - 1 > r) l = i, r = i + ret[i] - 1;
    }
    return ret;
}

array<vector<int>, 2> manacher(const string &s) {
    int n = (int)s.size();
    array<vector<int>, 2> p = {vector<int>(n), vector<int>(n)};
    for (int z = 0; z < 2; z++) { // z = 0: even, z = 1: odd
        for (int i = 0, l = 0, r = 0; i < n; i++) { 
            if (i < r) p[z][i] = min(r - i + !z, p[z][l + r - i + !z]);
            int L = i - p[z][i], R = i + p[z][i] - !z;
            while (L && R + 1 < n && s[L - 1] == s[R + 1]) p[z][i]++, L--, R++;
            if(R > r) l = L, r = R;
        }
        if (z) for (int i = 0; i < n; i++) p[z][i]++;
    }
    return p;
}

// Maxflow

template<class S> struct flow_network {
  private:
    int _n;
    template<class T> struct edge { int to, rev; T f, c; };

    vector<vector<edge<S>>> g;
    vector<S> xs;
    vector<stack<int>> ovfl;
    vector<int> h, cnt_h;
    vector<edge<S> *> cur;
  public:
    flow_network() : _n(0) {}
    flow_network(int n) : _n(n), g(n), xs(n), 
        ovfl(n << 1), h(n), cnt_h(n << 1), cur(n) {}

    void add_edge(int u, int v, S cap, S rcap = S(0)) {
        assert(0 <= u && u < _n && 0 <= v && v < _n);
        assert(S(0) <= cap);
        if (u == v) return;
        g[u].push_back({v, sz(g[v]), 0, cap});
        g[v].push_back({u, sz(g[u]) - 1, 0, rcap});
    }

    void push(edge<S> &e, S delta) {
        edge<S> &r = g[e.to][e.rev];
        if (!xs[e.to] && delta) ovfl[h[e.to]].push(e.to);
        e.f += delta, e.c -= delta, xs[e.to] += delta;
        r.f -= delta, r.c += delta, xs[r.to] -= delta;
    }

    S calc(int s, int t) {
        assert(0 <= s && s < _n && 0 <= t && t < _n);
        h[s] = _n, xs[t] = 1, cnt_h[0] = _n - 1;
        for (int i = 0; i < _n; i++) cur[i] = g[i].data();
        for (auto &e : g[s]) push(e, e.c);

        for (int cur_h = 0;;) {
            while (ovfl[cur_h].empty()) if (!cur_h--) return -xs[s];
            int u = ovfl[cur_h].top(); ovfl[cur_h].pop();

            while (xs[u] > 0) { // discharge u
                if (cur[u] == g[u].data() + sz(g[u])) {
                    h[u] = (_n << 1);
                    for (auto &e : g[u]) if (e.c && h[u] > h[e.to] + 1)
                        h[u] = h[e.to] + 1, cur[u] = &e;
                    if (++cnt_h[h[u]], !--cnt_h[cur_h] && cur_h)
                        for (int i = 0; i < _n; i++)
                            if (cur_h < h[i] && h[i] < _n)
                                cnt_h[h[i]]--, h[i] = _n + 1;
                    cur_h = h[u];
                } else if (cur[u]->c && h[u] == h[cur[u]->to] + 1)
                    push(*cur[u], min(xs[u], cur[u]->c));
                else ++cur[u];
            }
        }
    }

    bool left_of_min_cut(int u) { return h[u] >= _n; }
};

// Mincost-Maxflow

template<class F, class C> struct MCMF {
  private:
    template<class T> bool ckmin(T &u, T v) { return u > v ? (u = v, 1) : 0; }
    struct edge { int v; F flow, cap; C cost; };
    int _n;
    vector<C> p, dist;
    vector<int> prv;
    vector<vector<int>> adj;
    vector<edge> el;

  public:
    MCMF(int n) : _n(n), p(n), dist(n), prv(n), adj(n) {}

    void add_edge(int u, int v, F cap, C cost) {
        assert(cap > 0);
        adj[u].push_back(sz(el)); el.push_back({ v, 0, cap, cost });
        adj[v].push_back(sz(el)); el.push_back({ u, 0, 0, -cost });
    }

    bool path(int s, int t) {
        const C INF = numeric_limits<C>::max();
        fill(all(dist), INF);
        using T = pair<C, int>;
        priority_queue<T, vector<T>, greater<T>> pq; pq.emplace(dist[s] = 0, s);
        while (!pq.empty()) {
            T u = pq.top(); pq.pop();
            if (u.first > dist[u.second]) continue;
            for (auto i : adj[u.second]) {
                const edge &e = el[i];
                if (e.flow < e.cap && 
                ckmin(dist[e.v], u.first + e.cost + p[u.second] - p[e.v]))
                    prv[e.v] = i, pq.emplace(dist[e.v], e.v);
            }
        }
        return dist[t] != INF;
    }

    pair<F, C> calc(int s, int t) {
        assert(s != t);
        for (int i = 0; i < _n; i++) for (int j = 0; j < sz(el); j++) {
            const edge &e = el[j];
            if (e.cap) ckmin(p[e.v], p[el[j ^ 1].v] + e.cost);
        }
        F totFlow = 0;
        C totCost = 0;
        while (path(s, t)) {
            for (int i = 0; i < _n; i++) p[i] += dist[i];
            F df = numeric_limits<F>::max();
            for (int i = t; i != s; i = el[prv[i] ^ 1].v) {
                const edge &e = el[prv[i]];
                ckmin(df, e.cap - e.flow);
            }
            totFlow += df, totCost += (p[t] - p[s]) * df;
            for (int x = t; x != s; x = el[prv[x] ^ 1].v)
                el[prv[x]].flow += df, el[prv[x] ^ 1].flow -= df;
        }
        return { totFlow, totCost };
    }
};

// Manhattan MST

struct pt {
    long long x, y;
    pt() {}
    pt(long long _x, long long _y) : x(_x), y(_y) {}
};

struct edge {
    int u, v; long long c;
    edge() {}
    edge(int _u, int _v, long long _c) : u(_u), v(_v), c(_c) {}
    bool operator<(const edge &rhs) const { return c < rhs.c; }
};
    
struct disjoint_set {
    vector<int> rt, rnk;
    disjoint_set(int _sz) : rt(_sz + 1), rnk(_sz + 1, 1) { iota(all(rt), 0); }
    int find(int x) { return (x == rt[x] ? x : rt[x] = find(rt[x])); }
    bool unite(int u, int v) {
        u = find(u), v = find(v); if (u == v) return false;
        if (rnk[u] < rnk[v]) swap(u, v);
        return rt[v] = u, rnk[u] += rnk[v], true;
    }
};

vector<edge> manhattan_mst(vector<pt> arr) {
    vector<edge> res1;
    vector<int> idx(arr.size()); iota(all(idx), 0);
    for (int dir = 0; dir < 4; dir++) {
        for (auto &it : arr) {
            if (dir & 1) swap(it.x, it.y);
            else if (dir == 2) it.x = -it.x;
        }
        sort(all(idx), [&arr](int u, int v) { return arr[u].x - arr[v].x < arr[v].y - arr[u].y; });

        map<long long, int> mp;
        for (int u : idx) {
            for (auto it = mp.lower_bound(-arr[u].y); it != mp.end(); it = mp.erase(it)) {
                int v = it->second;
                if (arr[u].x - arr[v].x < arr[u].y - arr[v].y) break;
                res1.emplace_back(u, v, arr[u].x - arr[v].x + arr[u].y - arr[v].y);
            }
            mp.emplace(-arr[u].y, u);
        }
    }

    sort(all(res1));
    disjoint_set conn(res1.size());
    vector<edge> res2;
    for (auto e : res1) if (conn.unite(e.u, e.v)) res2.push_back(e);
    return res2;
}

// Line Container

inline namespace _LineContainer {
    typedef long long ll;
    const ll LINF = LLONG_MAX;
    bool _Line_Comp;

    struct Line {
        // k is slope, m is intercept, p is intersection point
        mutable ll k, m, p;
        bool operator<(const Line &o) const { return _Line_Comp ? p < o.p : k < o.k; }
    };

    struct LineContainer : multiset<Line> {
        ll div(ll a, ll b) { return a / b - ((a ^ b) < 0 && a % b); }
        bool isect(iterator x, iterator y) {
            if (y == end()) return (x->p = LINF, false);
            if (x->k == y->k) x->p = (x->m > y->m ? LINF : -LINF);
            else x->p = div(y->m - x->m, x->k - y->k);
            return (x->p >= y->p);
        }
        void add(ll k, ll m) {
            auto z = insert({k, m, 0}), y = z++, x = y;
            while (isect(y, z)) z = erase(z);
            if (x != begin() && isect(--x, y)) isect(x, y = erase(y));
            while ((y = x) != begin() && (--x)->p >= y->p) isect(x, erase(y));
        }
        ll query(ll x) {
            assert(!empty());
            _Line_Comp = 1;
            auto l = *lower_bound({0, 0, x});
            _Line_Comp = 0;
            return l.k * x + l.m;
        }
    };
}  // namespace _LineContainer

// Segment tree

template<class S, S (*op)(S, S), S (*e)()> struct segtree {
  private:
    int _n, _size;
    vector<S> d;
    void pull(int k) { d[k] = op(d[k << 1], d[k << 1 | 1]); }
  public:
    segtree() : segtree(0) {}
    segtree(int n) : segtree(vector<S>(n, e())) {}
    segtree(const vector<S> &v) : _n(sz(v)) {
        _size = (_n == 1 ? 1 : 1 << (32 - __builtin_clz(_n - 1)));
        d = vector<S>(_size << 1, e());
        for (int i = 0; i < _n; i++) d[i + _size] = v[i];
        for (int i = _size - 1; i >= 1; i--) pull(i);
    }

    void replace(int p, S x) {
        assert(0 <= p && p < _n);
        d[p + _size] = x;
        for (p = (p + _size) >> 1; p > 0; p >>= 1) pull(p);
    }

    S query(int p) const {
        assert(0 <= p && p < _n);
        return d[p + _size];
    }

    S query(int l, int r) const { // [l, r)
        assert(0 <= l && l <= r && r <= _n);
        S sml = e(), smr = e();
        for (l += _size, r += _size; l < r; l >>= 1, r >>= 1) {
            if (l & 1) sml = op(sml, d[l++]);
            if (r & 1) smr = op(d[--r], smr);
        }
        return op(sml, smr);
    }

    S query_all() const { return d[1]; }

    template<bool (*f)(S)> int max_right(int l) const {
        return max_right(l, [](S x) { return f(x); });
    }
    template<class F> int max_right(int l, F f) const {
        assert(0 <= l && l <= _n); assert(f(e()));
        if (l == _n) return _n;
        l += _size;
        S sm = e(), v;
        do {
            l >>= __builtin_ctz(l);
            if (!f(op(sm, d[l]))) {
                while (l < _size) {
                    l <<= 1, v = op(sm, d[l]);
                    if (f(v)) sm = v, l++;
                }
                return l - _size;
            }
            sm = op(sm, d[l++]);
        } while (l != (l & -l));
        return _n;
    }

    template<bool (*f)(S)> int min_left(int r) const {
        return min_left(r, [](S x) { return f(x); });
    }
    template<class F> int min_left(int r, F f) const {
        assert(0 <= r && r <= _n); assert(f(e()));
        if (r == 0) return 0;
        r += _size;
        S sm = e(), v;
        do {
            r--; r >>= __builtin_ctz(~r); if (!r) r = 1;
            if (!f(op(d[r], sm))) {
                while (r < _size) {
                    r = r << 1 | 1, v = op(d[r], sm);
                    if (f(v)) sm = v, r--;
                }
                return r + 1 - _size;
            }
            sm = op(d[r], sm);
        } while (r != (r & -r));
        return 0;
    }
};
